-------------------作品概要-------------------

作品名　　　　　：「SPIN LAMB!」
ジャンル　　　　： 3D押し出しアクションゲーム
プレイ人数　　　： 1人～2人
使用エンジン　　： 学校で使用したゲームエンジン
開発環境　　　　： VisualStudio2022,DirectX11
必要ライブラリ　： FBX SDK
作品リンク　　　： https://github.com/w4145n784q0/SpinLamb
制作期間　　　　： 9か月
動作環境　　　　： PC
制作人数　　　　： 1名(個人製作)


●ゲーム内容：
四方を柵に囲まれたフィールドを転がりながら、互いに衝突し合い、柵に接触させる3Dアクションゲームです。
相手を柵に衝突させると自分にポイントが1点入り、制限時間内にポイントを多く取った方が勝利となります。

●操作方法：

・キーボードの場合
矢印キー　　　　　　　　　　：移動
ＳＰＡＣＥキー　　　　　　　：ジャンプ
ＳＨＩＦＴキー長押し　　　　：チャージ
ＳＨＩＦＴキーを離す　　　　：ダッシュ攻撃
チャージ中にＳＰＡＣＥキー　：チャージ状態を解除
ＷＡＳＤキー　　　　　　　　：カメラ移動
Ｚキー　　　　　　　　　　　：カメラリセット
ＥＳＣキー　　　　　　　　　：ポーズ画面を開く

・XBOXコントローラーの場合
左スティック　　　　　　　　：移動
Ａボタン　　　　　　　　　　：ジャンプ
Ｂボタン長押し　　　　　　　：チャージ
Ｂボタンを離す　　　　　　　：ダッシュ攻撃
チャージ中にＡボタン　　　　：チャージ状態を解除
右スティック　　　　　　　　：カメラ移動
Ｘ・Ｙボタン　　　　　　　　：カメラリセット
ＳＴＡＲＴボタン　　　　　　：ポーズ画面を開く
　
●コンセプト：
一言で言うと「短時間かつシンプル操作で遊べるアクションゲーム」

過去のチーム制作で課題として挙がった「初見だと何をすればいいのかわかりにくい」「操作が難しい」「リプレイ性が低い」といった反省を活かすため、
「短時間でも面白さが伝わるようにすること」を意識し、このゲームを制作しました。

●設計面のコンセプト（ゲームデザイン）

①目的の明確化
「相手を場外にぶつける」というシンプルな勝利条件に絞り、周囲を鋭い棘の柵で囲み「ここに触れたらアウト」と直感的に理解できる環境をデザインしました。

②シンプル操作・短時間設計
過去の課題（操作が難しい、リプレイ性が低い）を踏まえ、遊ぶ方がすぐに目的を理解し、短い時間でも遊び切れるように工夫しました。

③簡易操作と駆け引きのバランス
主な操作が「移動」「突進」「ジャンプ」とシンプルな中でも駆け引きが生まれるよう、「チャージ中は無防備なうえ、長くチャージしていると自身が吹き飛ばされたときの距離が長くなる（リスク）」と「チャージする時間が長い程大きく吹き飛ばせる（リターン）」という二つのゲーム性を意識して制作しました。

●アプリ面のコンセプト（UI/UX・機能）

①ゲーム内演出による「わかりやすさ」の増強
ダッシュ攻撃中に集中線のスプライトを入れたり、接触時のヒットストップや画面振動、残り時間が10秒になったときのタイマー注目演出など「何が起きたかわからない」という要素を減らし、お客様が見てわかりやすいゲーム演出を取り入れてきました。

②遊び方確認機能
ゲーム前に操作やルールを確認できる機能や、実際にキャラクターを動かし動作を確かめられる練習モードを実装し、初めて遊ぶ方でも迷わず遊べるようにしました。

③操作感やストレスフリーを意識したUI・UX
タイトル画面から同じボタンを3回押すだけでゲーム画面に遷移できるようUIを配置したり、各シーンからすぐにメニューやタイトル画面に戻れるようにして、ゲーム以外においてもUXが快適になるように工夫しました。


●技術面アピールポイント

①共通の基底クラスと委譲による役割分け(Characterクラス・CharacterAirなど、Characterから始まる各モジュールクラス)

自身が動かすPlayerクラスと、CPUの処理を行うEnemyクラスの共通部分をCharacterクラスにまとめ、PlayerとEnemyはCharacterを継承するようにしました。
しかし、基底クラスの責任範囲が広すぎる点が企業の方からのフィードバックとして挙げられました。そのためパラメータ管理や各機能など役割ごとにモジュール化し、責務を細かく分割する形に改善しました。これによりコードの整理と各ソースファイルの独立性の向上につながりました。


②ステートパターンを使用した状態遷移(PlayerStateIdle,EnemyStateRootなど、PlayerおよびEnemyで使用している各状態クラス)

初期段階ではPlayerやEnemyの状態遷移をクラスのメンバ変数で管理していましたが、状態を追加する度に更新関数を変更する必要があり手間がかかっていました。
そのためステートパターンを導入し、状態をクラスとして独立させ、PlayerおよびEnemyでは同じ更新処理を呼びだすだけで完結するようにしました。そのため新規で状態を追加する際も追加するソースコードが最低限で済み、拡張性が向上しました。


③CSV読み込みやImGuiを使用したデータ管理(CharacterCSVLoaderクラス、HUDクラス、StageManagerクラスなど)

PlayerやEnemyの初期位置や移動速度、ステージモデルの拡大率、UIの座標など、ゲーム内のあらゆるパラメータをcsv形式で読み込み、csvファイルから直接入力できるようにしました。また、ゲームを起動中でもパラメータを確認できるようにImGuiを導入しました。そうすることで、他職種の方でもデータを確認および変更しやすくなり、デバッグの手間を大幅に改善できました。


④各プレイシーンと描画クラス・計算クラスの責務分離

UIに関する処理と描画の責務が混在し、役割が不明瞭になる問題があったため、
描画処理をHUDクラスおよび役割をモジュール化した関連クラスに集約し、時間計測やマップ情報の計算はGameTimerクラスおよびMiniMapクラスに分離しました。
さらに、BattleSceneやPracticeSceneから描画指示を行う構成とすることで、各クラスの責務を明確化し、保守性と可読性を向上させました。


⑤画面分割の実装および二人プレイの実現

5月末にゲーム業界の方にテストプレイしていただいた際に、
「複数人で遊べるともっと楽しそう」というフィードバックをいただきました。
そこで、複数のビューポートを扱える構造に変更し、シーンに応じて画面分割を切り替えられるように設計しました。
その結果、2人同時プレイが可能となったほか、映す対象に応じて描画する回数を切り替えられるようになり、柔軟な演出が可能となりました。
